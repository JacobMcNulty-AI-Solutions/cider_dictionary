# Venue Analytics Module
# Price analysis, heat maps, and venue intelligence for optimal cider discovery

## Core Data Structures

STRUCTURE: VenueAnalytics
    venueId: string
    averagePrice: float
    priceRange: {min: float, max: float}
    pricePerML: float
    cidersCount: integer
    uniqueProducersCount: integer
    uniqueStylesCount: integer
    inventoryFreshness: float // 0-100 score
    priceCompetitiveness: float // 0-100 score
    diversityScore: float // 0-100 score
    valueRating: float // 1-5 stars
    popularityScore: float
    lastAnalyzed: timestamp

STRUCTURE: PriceHeatMap
    regionId: string
    styleId: string
    priceData: List<PricePoint>
    averagePrice: float
    medianPrice: float
    priceDeviation: float
    sampleSize: integer
    confidenceLevel: float
    lastUpdated: timestamp

STRUCTURE: PricePoint
    venueId: string
    price: float
    volume: integer // ml
    pricePerML: float
    currency: string
    recordedAt: timestamp
    isValid: boolean

STRUCTURE: VenueIntelligence
    venueId: string
    bestDeals: List<CiderDeal>
    overpriced: List<CiderDeal>
    uniqueFinds: List<Cider>
    restockPatterns: List<RestockPattern>
    priceHistory: List<PriceHistoryPoint>
    competitiveAdvantages: List<string>
    weaknesses: List<string>
    recommendations: List<VenueRecommendation>

STRUCTURE: CiderDeal
    ciderId: string
    venueId: string
    currentPrice: float
    marketAverage: float
    savings: float
    savingsPercentage: float
    dealQuality: enum(EXCELLENT, GOOD, FAIR)
    reasoning: string
    volume: integer

STRUCTURE: MarketAnalysis
    styleId: string
    regionId: string
    averagePrice: float
    priceRange: {min: float, max: float}
    topVenues: List<VenueRanking>
    priceLeaders: List<VenueRanking>
    qualityLeaders: List<VenueRanking>
    marketTrends: List<PriceTrend>
    lastAnalyzed: timestamp

## Price Analysis Engine

ALGORITHM: CalculateVenueAnalytics
INPUT: venueId (string)
OUTPUT: VenueAnalytics

BEGIN
    venue ← Database.getVenue(venueId)
    venueCiders ← Database.getVenueCiders(venueId)

    analytics ← VenueAnalytics()
    analytics.venueId ← venueId
    analytics.cidersCount ← venueCiders.length

    IF venueCiders.length = 0 THEN
        RETURN CreateEmptyAnalytics(venueId)
    END IF

    // Basic price metrics
    prices ← EXTRACT venueCiders.price WHERE price IS NOT NULL
    analytics.averagePrice ← AVERAGE(prices)
    analytics.priceRange ← {min: MIN(prices), max: MAX(prices)}

    // Price per ML analysis
    volumePrices ← []
    FOR EACH cider IN venueCiders DO
        IF cider.price IS NOT NULL AND cider.volume IS NOT NULL THEN
            pricePerML ← cider.price / cider.volume
            volumePrices.append(pricePerML)
        END IF
    END FOR

    IF volumePrices.length > 0 THEN
        analytics.pricePerML ← AVERAGE(volumePrices)
    END IF

    // Diversity metrics
    analytics.uniqueProducersCount ← GetUniqueCount(venueCiders, "producerId")
    analytics.uniqueStylesCount ← GetUniqueCount(venueCiders, "styleId")
    analytics.diversityScore ← CalculateVenueDiversityScore(venueCiders)

    // Competitive analysis
    analytics.priceCompetitiveness ← CalculatePriceCompetitiveness(
        venueCiders, venue.regionId
    )

    // Inventory freshness
    analytics.inventoryFreshness ← CalculateInventoryFreshness(venueCiders)

    // Overall value rating
    analytics.valueRating ← CalculateValueRating(analytics)

    // Popularity score
    analytics.popularityScore ← CalculateVenuePopularity(venueId)

    analytics.lastAnalyzed ← CurrentTimestamp()

    // Cache results
    Cache.set("venue_analytics:" + venueId, analytics, TTL_2_HOURS)

    RETURN analytics
END

ALGORITHM: CalculatePriceCompetitiveness
INPUT: venueCiders (List<Cider>), regionId (string)
OUTPUT: competitiveness (float) // 0-100 score

BEGIN
    competitivePrices ← 0
    totalComparisons ← 0

    FOR EACH cider IN venueCiders DO
        IF cider.price IS NOT NULL THEN
            marketPrice ← GetMarketAveragePrice(cider.ciderId, regionId)

            IF marketPrice IS NOT NULL THEN
                totalComparisons ← totalComparisons + 1

                // Calculate competitiveness for this cider
                IF cider.price <= marketPrice THEN
                    competitivePrices ← competitivePrices + 1
                ELSE
                    // Partial credit for prices within 10% of market
                    priceDiff ← (cider.price - marketPrice) / marketPrice
                    IF priceDiff <= 0.1 THEN
                        competitivePrices ← competitivePrices + 0.5
                    END IF
                END IF
            END IF
        END IF
    END FOR

    IF totalComparisons = 0 THEN
        RETURN 50.0 // Neutral score when no comparisons possible
    END IF

    competitiveness ← (competitivePrices / totalComparisons) * 100
    RETURN competitiveness
END

## Heat Map Generation

ALGORITHM: GeneratePriceHeatMap
INPUT: regionId (string), styleId (string)
OUTPUT: PriceHeatMap

BEGIN
    cacheKey ← "heatmap:" + regionId + ":" + styleId
    cached ← Cache.get(cacheKey)

    IF cached IS NOT NULL AND (CurrentTime() - cached.lastUpdated) < 6_HOURS THEN
        RETURN cached
    END IF

    // Gather price data
    venues ← Database.getVenuesByRegion(regionId)
    priceData ← []

    FOR EACH venue IN venues DO
        venueCiders ← Database.getVenueCidersByStyle(venue.id, styleId)

        FOR EACH cider IN venueCiders DO
            IF cider.price IS NOT NULL AND cider.volume IS NOT NULL THEN
                pricePoint ← PricePoint()
                pricePoint.venueId ← venue.id
                pricePoint.price ← cider.price
                pricePoint.volume ← cider.volume
                pricePoint.pricePerML ← cider.price / cider.volume
                pricePoint.currency ← cider.currency
                pricePoint.recordedAt ← cider.lastUpdated
                pricePoint.isValid ← ValidatePricePoint(pricePoint)

                IF pricePoint.isValid THEN
                    priceData.append(pricePoint)
                END IF
            END IF
        END FOR
    END FOR

    // Generate heat map
    heatMap ← PriceHeatMap()
    heatMap.regionId ← regionId
    heatMap.styleId ← styleId
    heatMap.priceData ← priceData
    heatMap.sampleSize ← priceData.length

    IF priceData.length >= 3 THEN
        prices ← EXTRACT priceData.pricePerML
        heatMap.averagePrice ← AVERAGE(prices)
        heatMap.medianPrice ← MEDIAN(prices)
        heatMap.priceDeviation ← STANDARD_DEVIATION(prices)
        heatMap.confidenceLevel ← CalculateConfidenceLevel(priceData.length)
    ELSE
        heatMap.confidenceLevel ← 0.0
    END IF

    heatMap.lastUpdated ← CurrentTimestamp()

    // Cache results
    Cache.set(cacheKey, heatMap, TTL_6_HOURS)

    RETURN heatMap
END

ALGORITHM: ValidatePricePoint
INPUT: pricePoint (PricePoint)
OUTPUT: isValid (boolean)

BEGIN
    // Price range validation
    IF pricePoint.price <= 0 OR pricePoint.price > 1000 THEN
        RETURN false
    END IF

    // Volume validation
    IF pricePoint.volume <= 0 OR pricePoint.volume > 5000 THEN
        RETURN false
    END IF

    // Price per ML validation (outlier detection)
    pricePerML ← pricePoint.pricePerML
    IF pricePerML < 0.001 OR pricePerML > 10.0 THEN
        RETURN false
    END IF

    // Freshness validation
    daysSinceRecorded ← (CurrentTime() - pricePoint.recordedAt).days
    IF daysSinceRecorded > 365 THEN
        RETURN false
    END IF

    RETURN true
END

## Deal Detection System

ALGORITHM: IdentifyBestDeals
INPUT: regionId (string), userId (string), limit (integer)
OUTPUT: deals (List<CiderDeal>)

BEGIN
    userPreferences ← GetUserPreferences(userId)
    venues ← Database.getVenuesByRegion(regionId)
    allDeals ← []

    FOR EACH venue IN venues DO
        venueDeals ← AnalyzeVenueDeals(venue, userPreferences)
        allDeals.extend(venueDeals)
    END FOR

    // Score and rank deals
    FOR EACH deal IN allDeals DO
        deal.score ← ScoreDeal(deal, userPreferences)
    END FOR

    // Sort by score and preference match
    allDeals.sortByDescending(score)

    // Filter for quality deals
    qualityDeals ← FILTER allDeals WHERE dealQuality IN [EXCELLENT, GOOD]

    RETURN qualityDeals.slice(0, limit)
END

ALGORITHM: AnalyzeVenueDeals
INPUT: venue (Venue), preferences (UserPreferences)
OUTPUT: deals (List<CiderDeal>)

BEGIN
    venueCiders ← Database.getVenueCiders(venue.id)
    deals ← []

    FOR EACH cider IN venueCiders DO
        IF cider.price IS NOT NULL THEN
            marketAverage ← GetMarketAveragePrice(cider.ciderId, venue.regionId)

            IF marketAverage IS NOT NULL THEN
                savings ← marketAverage - cider.price
                savingsPercentage ← (savings / marketAverage) * 100

                // Only consider actual savings
                IF savings > 0 AND savingsPercentage >= 5.0 THEN
                    deal ← CiderDeal()
                    deal.ciderId ← cider.ciderId
                    deal.venueId ← venue.id
                    deal.currentPrice ← cider.price
                    deal.marketAverage ← marketAverage
                    deal.savings ← savings
                    deal.savingsPercentage ← savingsPercentage
                    deal.volume ← cider.volume
                    deal.dealQuality ← ClassifyDealQuality(savingsPercentage)
                    deal.reasoning ← GenerateDealReasoning(deal, marketAverage)

                    deals.append(deal)
                END IF
            END IF
        END IF
    END FOR

    RETURN deals
END

ALGORITHM: ClassifyDealQuality
INPUT: savingsPercentage (float)
OUTPUT: quality (enum)

BEGIN
    IF savingsPercentage >= 25.0 THEN
        RETURN EXCELLENT
    ELSE IF savingsPercentage >= 15.0 THEN
        RETURN GOOD
    ELSE IF savingsPercentage >= 5.0 THEN
        RETURN FAIR
    ELSE
        RETURN POOR
    END IF
END

## Venue Intelligence System

ALGORITHM: GenerateVenueIntelligence
INPUT: venueId (string), userId (string)
OUTPUT: VenueIntelligence

BEGIN
    venue ← Database.getVenue(venueId)
    userPreferences ← GetUserPreferences(userId)

    intelligence ← VenueIntelligence()
    intelligence.venueId ← venueId

    // Parallel analysis tasks
    dealsTask ← AsyncTask(IdentifyVenueDeals, venueId, userPreferences)
    uniqueTask ← AsyncTask(FindUniqueVenueCiders, venueId)
    patternsTask ← AsyncTask(AnalyzeRestockPatterns, venueId)
    historyTask ← AsyncTask(GetVenuePriceHistory, venueId)

    // Gather results
    intelligence.bestDeals ← AWAIT dealsTask
    intelligence.uniqueFinds ← AWAIT uniqueTask
    intelligence.restockPatterns ← AWAIT patternsTask
    intelligence.priceHistory ← AWAIT historyTask

    // Identify overpriced items
    intelligence.overpriced ← IdentifyOverpricedItems(venueId)

    // Generate competitive analysis
    competitive ← AnalyzeVenueCompetitivePosition(venue)
    intelligence.competitiveAdvantages ← competitive.advantages
    intelligence.weaknesses ← competitive.weaknesses

    // Generate recommendations
    intelligence.recommendations ← GenerateVenueRecommendations(
        venue, userPreferences, intelligence
    )

    RETURN intelligence
END

ALGORITHM: FindUniqueVenueCiders
INPUT: venueId (string)
OUTPUT: uniqueCiders (List<Cider>)

BEGIN
    venueCiders ← Database.getVenueCiders(venueId)
    uniqueCiders ← []

    FOR EACH cider IN venueCiders DO
        // Check if cider is available at other venues in region
        otherVenues ← Database.countVenuesWithCider(
            cider.ciderId, venueId.region, excludeVenue: venueId
        )

        // Consider unique if available at 2 or fewer other venues
        IF otherVenues <= 2 THEN
            uniqueCiders.append(cider)
        END IF
    END FOR

    // Sort by rarity and quality
    uniqueCiders.sortBy(otherVenues ASC, rating DESC)

    RETURN uniqueCiders
END

ALGORITHM: AnalyzeRestockPatterns
INPUT: venueId (string)
OUTPUT: patterns (List<RestockPattern>)

BEGIN
    // Analyze historical inventory changes
    inventoryHistory ← Database.getVenueInventoryHistory(venueId, 180_DAYS)
    patterns ← []

    // Group by producer/style for pattern detection
    groupedData ← GroupBy(inventoryHistory, ["producerId", "styleId"])

    FOR EACH group IN groupedData DO
        pattern ← DetectRestockPattern(group)
        IF pattern.confidence >= 0.7 THEN
            patterns.append(pattern)
        END IF
    END FOR

    RETURN patterns
END

## Market Analysis

ALGORITHM: GenerateMarketAnalysis
INPUT: regionId (string), styleId (string)
OUTPUT: MarketAnalysis

BEGIN
    analysis ← MarketAnalysis()
    analysis.styleId ← styleId
    analysis.regionId ← regionId

    // Gather market data
    venues ← Database.getVenuesByRegion(regionId)
    allPrices ← []
    venuePerformance ← []

    FOR EACH venue IN venues DO
        venueCiders ← Database.getVenueCidersByStyle(venue.id, styleId)

        IF venueCiders.length > 0 THEN
            venuePrices ← EXTRACT venueCiders.price WHERE price IS NOT NULL
            venueAverage ← AVERAGE(venuePrices)

            venuePerformance.append({
                venueId: venue.id,
                averagePrice: venueAverage,
                cidersCount: venueCiders.length,
                uniqueProducers: GetUniqueCount(venueCiders, "producerId")
            })

            allPrices.extend(venuePrices)
        END IF
    END FOR

    // Calculate market metrics
    IF allPrices.length > 0 THEN
        analysis.averagePrice ← AVERAGE(allPrices)
        analysis.priceRange ← {min: MIN(allPrices), max: MAX(allPrices)}
    END IF

    // Rank venues
    analysis.topVenues ← RankVenuesByOverallScore(venuePerformance)
    analysis.priceLeaders ← RankVenuesByPrice(venuePerformance, "ASC")
    analysis.qualityLeaders ← RankVenuesByQuality(venuePerformance)

    // Analyze trends
    analysis.marketTrends ← AnalyzePriceTrends(regionId, styleId, 365_DAYS)

    analysis.lastAnalyzed ← CurrentTimestamp()

    RETURN analysis
END

## Value Rating System

ALGORITHM: CalculateValueRating
INPUT: analytics (VenueAnalytics)
OUTPUT: rating (float) // 1.0-5.0 stars

BEGIN
    // Multi-factor value assessment
    scores ← []

    // Price competitiveness (40% weight)
    priceScore ← analytics.priceCompetitiveness / 20.0 // Convert to 0-5 scale
    scores.append({score: priceScore, weight: 0.4})

    // Inventory diversity (25% weight)
    diversityScore ← analytics.diversityScore / 20.0
    scores.append({score: diversityScore, weight: 0.25})

    // Inventory freshness (20% weight)
    freshnessScore ← analytics.inventoryFreshness / 20.0
    scores.append({score: freshnessScore, weight: 0.2})

    // Selection size (15% weight)
    selectionScore ← CalculateSelectionScore(analytics.cidersCount)
    scores.append({score: selectionScore, weight: 0.15})

    // Calculate weighted average
    weightedSum ← 0
    totalWeight ← 0

    FOR EACH score IN scores DO
        weightedSum ← weightedSum + (score.score * score.weight)
        totalWeight ← totalWeight + score.weight
    END FOR

    rating ← weightedSum / totalWeight

    // Ensure rating is within bounds
    rating ← MAX(1.0, MIN(5.0, rating))

    RETURN rating
END

ALGORITHM: CalculateSelectionScore
INPUT: cidersCount (integer)
OUTPUT: score (float) // 0-5 scale

BEGIN
    // Logarithmic scaling for selection size
    IF cidersCount <= 0 THEN
        RETURN 0.0
    ELSE IF cidersCount >= 500 THEN
        RETURN 5.0
    ELSE
        // Scale using natural log
        normalizedCount ← LOG(cidersCount + 1) / LOG(501)
        RETURN normalizedCount * 5.0
    END IF
END

## Real-time Price Monitoring

ALGORITHM: MonitorPriceChanges
INPUT: None (background task)
OUTPUT: None (triggers notifications)

BEGIN
    // Monitor venues with frequent price changes
    monitoredVenues ← Database.getVenuesWithPriceTracking()

    FOR EACH venue IN monitoredVenues DO
        currentPrices ← FetchCurrentVenuePrices(venue.id)
        storedPrices ← Database.getStoredPrices(venue.id)

        changes ← DetectPriceChanges(currentPrices, storedPrices)

        FOR EACH change IN changes DO
            IF change.isSignificant THEN
                // Update database
                Database.updateCiderPrice(change.ciderId, change.newPrice)

                // Trigger notifications for users tracking this cider/venue
                TriggerPriceChangeNotifications(change)

                // Update deal calculations
                InvalidateVenueDealsCache(venue.id)
            END IF
        END FOR
    END FOR
END

## Performance Optimizations

ALGORITHM: OptimizedRegionalAnalysis
INPUT: regionId (string)
OUTPUT: RegionalInsights

BEGIN
    // Use materialized views for common calculations
    cacheKey ← "regional_analysis:" + regionId

    cached ← Cache.get(cacheKey)
    IF cached IS NOT NULL AND (CurrentTime() - cached.lastCalculated) < 4_HOURS THEN
        RETURN cached
    END IF

    // Parallel processing of venue analytics
    venues ← Database.getVenuesByRegion(regionId)
    venueAnalyticsTasks ← []

    FOR EACH venue IN venues DO
        task ← AsyncTask(CalculateVenueAnalytics, venue.id)
        venueAnalyticsTasks.append(task)
    END FOR

    // Gather results
    venueAnalytics ← []
    FOR EACH task IN venueAnalyticsTasks DO
        analytics ← AWAIT task
        venueAnalytics.append(analytics)
    END FOR

    // Aggregate regional insights
    insights ← AggregateRegionalInsights(venueAnalytics)
    insights.lastCalculated ← CurrentTimestamp()

    // Cache with appropriate TTL
    Cache.set(cacheKey, insights, TTL_4_HOURS)

    RETURN insights
END

## API Endpoints

ENDPOINT: GET /api/venue-analytics/{venueId}
RETURNS: VenueAnalytics with comprehensive metrics

ENDPOINT: GET /api/deals/region/{regionId}
RETURNS: List<CiderDeal> sorted by value

ENDPOINT: GET /api/heatmap/prices
QUERY: regionId, styleId
RETURNS: PriceHeatMap with confidence levels

ENDPOINT: GET /api/venue-intelligence/{venueId}
RETURNS: VenueIntelligence with recommendations

ENDPOINT: GET /api/market-analysis/{regionId}/{styleId}
RETURNS: MarketAnalysis with trends

ENDPOINT: POST /api/venue-analytics/refresh/{venueId}
RETURNS: Updated analytics with cache invalidation

## Error Handling and Edge Cases

1. **Insufficient Data**: Graceful degradation with confidence indicators
2. **Price Outliers**: Statistical validation and outlier detection
3. **Stale Data**: Confidence scoring based on data freshness
4. **Regional Variations**: Currency normalization and local market context
5. **Venue Closures**: Automatic detection and data archival

## Time Complexity Analysis

- Venue Analytics: O(n) where n = venue's cider count
- Price Heat Map: O(v × c) where v = venues, c = ciders per venue
- Deal Detection: O(r × c × log c) where r = region venues, c = ciders
- Market Analysis: O(v × c) with caching optimizations

## Space Complexity Analysis

- Venue Analytics: O(1) - fixed size structure
- Heat Map Data: O(p) where p = price points
- Deal Storage: O(d) where d = identified deals
- Cache Usage: O(v + r) where v = venues, r = regions monitored