# Experience Logging Pseudocode
# Cider Dictionary - Core User Workflows Phase 2

## Overview
This pseudocode defines the experience logging workflow for tracking drinking occasions,
venue selection, price tracking, and location capture with intelligent venue consolidation
and automatic price per ml calculations.

## Experience Logging Architecture

### Experience Entry Controller
```
ALGORITHM: ExperienceEntryController
PURPOSE: Orchestrate experience logging with venue intelligence and price analytics

INTERFACE ExperienceEntryController:
    PROPERTIES:
        formState: ExperienceFormState
        venueDetector: VenueDetectionEngine
        priceCalculator: PriceCalculatorEngine
        locationService: LocationService
        validationEngine: ExperienceValidationEngine

    DEPENDENCIES:
        - ExperienceStore (Zustand)
        - VenueStore (Zustand)
        - CiderStore (for cider selection)
        - DatabaseService
        - UserPreferencesStore

FUNCTION initializeExperienceEntry(ciderId, context):
    INPUT: Cider ID and entry context
    OUTPUT: Initialized experience form state

    PRECONDITIONS:
        - Cider must exist in collection
        - User must be authenticated
        - Location services accessible (optional)

    BEGIN
        // Step 1: Validate cider exists
        cider = await getCiderById(ciderId)
        IF cider IS NULL THEN
            THROW CiderNotFoundError("Selected cider not found")
        END IF

        // Step 2: Initialize form with defaults
        formState = createInitialExperienceFormState(cider, context)

        // Step 3: Start location detection if enabled
        userPrefs = getUserPreferences()
        IF userPrefs.autoLocationCapture THEN
            this.locationService.startLocationDetection()
        END IF

        // Step 4: Load recent venues for quick selection
        recentVenues = await loadRecentVenues()
        formState.recentVenues = recentVenues

        // Step 5: Initialize price calculator with user preferences
        this.priceCalculator.initialize(userPrefs)

        // Step 6: Start analytics timer
        analytics.startTimer("experience_entry_session")

        RETURN formState
    END

    POSTCONDITIONS:
        - Form ready for user input
        - Location detection active (if enabled)
        - Recent venues loaded
        - Price calculator initialized
```

### Experience Form State Management
```
ALGORITHM: ExperienceFormState
PURPOSE: Manage experience entry form with real-time calculations

INTERFACE ExperienceFormState:
    CORE_FIELDS:
        ciderId: string (required, pre-filled)
        date: Date (required, defaults to current)
        venue: VenueData (required)
        price: number (required)
        containerSize: number (required, from preferences)

    OPTIONAL_FIELDS:
        experienceRating: number (optional, 1-10)
        notes: string (optional, max 1000 chars)
        companionCount: number (optional)
        weatherCondition: WeatherCondition (optional)

    CALCULATED_FIELDS:
        pricePerMl: number (computed from price/containerSize)
        valueRating: number (computed from rating/pricePerMl)
        isGoodValue: boolean (computed comparison)

    META_FIELDS:
        isValid: boolean (computed)
        errors: ValidationError[]
        warnings: ValidationWarning[]
        isDirty: boolean

FUNCTION createInitialExperienceFormState(cider, context):
    INPUT: Selected cider and context
    OUTPUT: Initial form state

    BEGIN
        userPrefs = getUserPreferences()

        state = {
            // Core required fields
            ciderId: cider.id,
            ciderName: cider.name,
            ciderBrand: cider.brand,
            date: getCurrentDate(),
            venue: null,
            price: null,
            containerSize: userPrefs.defaultContainerSize,

            // Optional fields
            experienceRating: null,
            notes: "",
            companionCount: null,
            weatherCondition: null,

            // Calculated fields (computed)
            pricePerMl: null,
            valueRating: null,
            isGoodValue: null,

            // Meta fields
            isValid: false,
            errors: [],
            warnings: [],
            isDirty: false,

            // UI state
            showOptionalFields: false,
            isSubmitting: false,
            recentVenues: [],
            locationSuggestions: []
        }

        // Apply context-specific defaults
        SWITCH context.type:
            CASE "re_visit":
                // Pre-fill from last experience at same venue
                IF context.lastExperience THEN
                    state.venue = context.lastExperience.venue
                    state.containerSize = context.lastExperience.containerSize
                END IF

            CASE "venue_context":
                // Pre-fill venue from location or context
                state.venue = context.venue

            DEFAULT:
                // Standard new experience entry
        END SWITCH

        RETURN state
    END
```

### Venue Detection and Intelligence
```
ALGORITHM: VenueDetectionEngine
PURPOSE: Intelligent venue detection, consolidation, and suggestions

INTERFACE VenueDetectionEngine:
    PROPERTIES:
        locationService: LocationService
        venueDatabase: VenueDatabase
        consolidationRules: VenueConsolidationRules
        geocoder: GeocodingService

FUNCTION detectVenueFromLocation(location):
    INPUT: GPS coordinates or address
    OUTPUT: Promise<VenueSuggestion[]>

    COMPLEXITY:
        Time: O(n) where n = stored venues + API call
        Space: O(n) for suggestions

    BEGIN
        suggestions = []

        // Step 1: Check for nearby known venues first
        nearbyVenues = await findNearbyKnownVenues(location)
        suggestions = suggestions.concat(nearbyVenues)

        // Step 2: Reverse geocode to get address info
        addressInfo = await this.geocoder.reverseGeocode(location)

        // Step 3: Extract potential venue names from address
        IF addressInfo.poi THEN
            poiSuggestions = extractPOISuggestions(addressInfo)
            suggestions = suggestions.concat(poiSuggestions)
        END IF

        // Step 4: Add generic location-based suggestions
        genericSuggestions = generateGenericSuggestions(addressInfo)
        suggestions = suggestions.concat(genericSuggestions)

        // Step 5: Rank and filter suggestions
        rankedSuggestions = rankVenueSuggestions(suggestions, location)

        RETURN rankedSuggestions.slice(0, 5)  // Top 5 suggestions
    END

FUNCTION findNearbyKnownVenues(location, radiusMeters = 100):
    INPUT: GPS location and search radius
    OUTPUT: Array of nearby known venues

    BEGIN
        userVenues = await getUserVenues()
        nearbyVenues = []

        FOR EACH venue IN userVenues DO
            IF venue.location THEN
                distance = calculateDistance(location, venue.location)

                IF distance <= radiusMeters THEN
                    confidence = calculateLocationConfidence(distance, radiusMeters)
                    nearbyVenues.append({
                        venue: venue,
                        distance: distance,
                        confidence: confidence,
                        source: "user_history"
                    })
                END IF
            END IF
        END FOR

        // Sort by distance
        nearbyVenues.sort((a, b) => a.distance - b.distance)

        RETURN nearbyVenues
    END

FUNCTION consolidateVenueName(rawVenueName, location):
    INPUT: Raw venue name and location
    OUTPUT: Consolidated venue data

    BEGIN
        // Step 1: Normalize the venue name
        normalizedName = normalizeVenueName(rawVenueName)

        // Step 2: Check for existing venues with similar names
        existingVenues = await findSimilarVenues(normalizedName, location)

        IF existingVenues.length > 0 THEN
            // Find best match
            bestMatch = findBestVenueMatch(normalizedName, location, existingVenues)

            IF bestMatch.confidence > 0.8 THEN
                // Use existing venue
                RETURN {
                    id: bestMatch.venue.id,
                    name: bestMatch.venue.name,
                    type: bestMatch.venue.type,
                    location: location,
                    isExisting: true,
                    consolidatedFrom: rawVenueName
                }
            END IF
        END IF

        // Step 3: Create new venue
        venueType = detectVenueType(normalizedName, location)
        venueId = generateVenueId(normalizedName, location)

        RETURN {
            id: venueId,
            name: normalizedName,
            type: venueType,
            location: location,
            isExisting: false,
            originalName: rawVenueName
        }
    END

FUNCTION normalizeVenueName(rawName):
    INPUT: Raw venue name from user input
    OUTPUT: Normalized venue name

    BEGIN
        normalized = rawName.toLowerCase().trim()

        // Apply chain store consolidation rules
        chainConsolidation = {
            "tesco": ["tesco extra", "tesco superstore", "tesco express", "tesco metro", "tesco petrol"],
            "sainsbury's": ["sainsburys", "sainsbury's local", "sainsbury's superstore", "sainsburys local"],
            "asda": ["asda superstore", "asda supermarket", "asda living"],
            "morrisons": ["morrisons supermarket", "morrisons daily"],
            "waitrose": ["waitrose & partners", "little waitrose", "waitrose local"],
            "marks & spencer": ["m&s", "marks and spencer", "m & s", "marks&spencer"],
            "costa coffee": ["costa", "costa coffee shop"],
            "starbucks": ["starbucks coffee", "starbucks cafe"],
            "weatherspoons": ["wetherspoons", "weatherspoon", "jd wetherspoon", "j d wetherspoon"]
        }

        FOR EACH [canonical, variations] IN chainConsolidation DO
            FOR EACH variation IN variations DO
                IF normalized.includes(variation) THEN
                    RETURN canonical
                END IF
            END FOR
        END FOR

        // Remove common suffixes that don't add value
        suffixesToRemove = [
            "pub", "public house", "tavern", "inn", "bar", "restaurant",
            "cafe", "coffee shop", "ltd", "limited", "plc", "& co", "and co"
        ]

        FOR EACH suffix IN suffixesToRemove DO
            pattern = new RegExp(`\\s+${suffix}\\s*$`, 'gi')
            normalized = normalized.replace(pattern, "")
        END FOR

        // Clean up extra whitespace
        normalized = normalized.replace(/\s+/g, " ").trim()

        RETURN normalized
    END

FUNCTION detectVenueType(venueName, location):
    INPUT: Normalized venue name and location
    OUTPUT: VenueType enum value

    BEGIN
        name = venueName.toLowerCase()

        // Direct chain mappings
        chainTypes = {
            "tesco": "tesco",
            "sainsbury's": "sainsburys",
            "asda": "asda",
            "morrisons": "morrisons",
            "waitrose": "waitrose",
            "aldi": "aldi",
            "lidl": "lidl",
            "marks & spencer": "marks_spencer",
            "iceland": "iceland",
            "coop": "coop"
        }

        FOR EACH [chain, type] IN chainTypes DO
            IF name.includes(chain) THEN
                RETURN type
            END IF
        END FOR

        // Keyword-based detection
        pubKeywords = ["pub", "tavern", "inn", "arms", "head", "crown", "royal", "king", "queen"]
        FOR EACH keyword IN pubKeywords DO
            IF name.includes(keyword) THEN
                RETURN "pub"
            END IF
        END FOR

        restaurantKeywords = ["restaurant", "bistro", "brasserie", "grill", "kitchen", "dining"]
        FOR EACH keyword IN restaurantKeywords DO
            IF name.includes(keyword) THEN
                RETURN "restaurant"
            END IF
        END FOR

        barKeywords = ["bar", "lounge", "cocktail", "wine bar"]
        FOR EACH keyword IN barKeywords DO
            IF name.includes(keyword) THEN
                RETURN "bar"
            END IF
        END FOR

        // Default fallback
        RETURN "other"
    END
```

### Price Calculator Engine
```
ALGORITHM: PriceCalculatorEngine
PURPOSE: Calculate price per ml and value ratings with context awareness

INTERFACE PriceCalculatorEngine:
    PROPERTIES:
        userPreferences: UserPreferences
        priceHistory: PriceHistoryDatabase
        valueThresholds: ValueThresholds

FUNCTION calculatePricePerMl(price, containerSize):
    INPUT: Price amount and container size in ml
    OUTPUT: Price per ml with validation

    COMPLEXITY:
        Time: O(1)
        Space: O(1)

    BEGIN
        IF price <= 0 THEN
            THROW InvalidPriceError("Price must be positive")
        END IF

        IF containerSize <= 0 THEN
            THROW InvalidContainerSizeError("Container size must be positive")
        END IF

        pricePerMl = price / containerSize

        // Round to reasonable precision (4 decimal places)
        pricePerMl = Math.round(pricePerMl * 10000) / 10000

        RETURN pricePerMl
    END

FUNCTION calculateValueRating(ciderRating, pricePerMl, context):
    INPUT: Cider rating, price per ml, and context
    OUTPUT: Value rating and classification

    BEGIN
        IF ciderRating IS NULL OR pricePerMl IS NULL THEN
            RETURN null
        END IF

        // Base value calculation: rating / price relationship
        baseValue = ciderRating / pricePerMl

        // Apply context adjustments
        contextMultiplier = calculateContextMultiplier(context)
        adjustedValue = baseValue * contextMultiplier

        // Normalize to 0-100 scale
        normalizedValue = normalizeValueScore(adjustedValue)

        // Classify value
        valueClassification = classifyValue(normalizedValue)

        RETURN {
            score: normalizedValue,
            classification: valueClassification,
            pricePerMl: pricePerMl,
            rating: ciderRating,
            context: context
        }
    END

FUNCTION calculateContextMultiplier(context):
    INPUT: Experience context (venue type, location, etc.)
    OUTPUT: Context adjustment multiplier

    BEGIN
        multiplier = 1.0

        // Venue type adjustments
        venueAdjustments = {
            "pub": 1.0,              // Baseline
            "restaurant": 0.8,       // Expected to be more expensive
            "bar": 0.7,              // Premium pricing expected
            "tesco": 1.3,            // Retail should be cheaper
            "sainsburys": 1.3,
            "asda": 1.4,             // Discount retailers
            "aldi": 1.5,
            "lidl": 1.5,
            "waitrose": 1.1,         // Premium retailer
            "marks_spencer": 1.0,
            "specialist_retailer": 0.9, // Specialty pricing expected
            "cidery_taproom": 0.8,   // Premium direct source
            "festival": 0.6          // Festival pricing expected
        }

        IF context.venue AND context.venue.type THEN
            venueMultiplier = venueAdjustments[context.venue.type] || 1.0
            multiplier *= venueMultiplier
        END IF

        // Time-based adjustments
        IF context.time THEN
            timeMultiplier = calculateTimeMultiplier(context.time)
            multiplier *= timeMultiplier
        END IF

        // Location adjustments (London vs regions, etc.)
        IF context.location THEN
            locationMultiplier = calculateLocationMultiplier(context.location)
            multiplier *= locationMultiplier
        END IF

        RETURN multiplier
    END

FUNCTION analyzePersonalPriceHistory(ciderId, venueId):
    INPUT: Cider ID and venue ID
    OUTPUT: Personal price analytics

    BEGIN
        // Get historical prices for this cider
        ciderPrices = await getPriceHistoryForCider(ciderId)

        // Get historical prices at this venue
        venuePrices = await getPriceHistoryForVenue(venueId)

        analytics = {
            ciderStats: calculateCiderPriceStats(ciderPrices),
            venueStats: calculateVenuePriceStats(venuePrices),
            comparison: null,
            recommendations: []
        }

        // Compare if we have both datasets
        IF ciderPrices.length > 0 AND venuePrices.length > 0 THEN
            analytics.comparison = comparePriceContexts(ciderPrices, venuePrices)
        END IF

        // Generate recommendations
        analytics.recommendations = generatePriceRecommendations(analytics)

        RETURN analytics
    END

FUNCTION calculateCiderPriceStats(priceHistory):
    INPUT: Array of price records for a cider
    OUTPUT: Price statistics

    BEGIN
        IF priceHistory.length == 0 THEN
            RETURN null
        END IF

        prices = priceHistory.map(record => record.pricePerMl)

        stats = {
            count: prices.length,
            min: Math.min(...prices),
            max: Math.max(...prices),
            average: prices.reduce((sum, p) => sum + p, 0) / prices.length,
            median: calculateMedian(prices),
            trend: calculatePriceTrend(priceHistory),
            lastPrice: priceHistory[priceHistory.length - 1].pricePerMl,
            lastVenue: priceHistory[priceHistory.length - 1].venue.name
        }

        RETURN stats
    END

FUNCTION generatePriceWarnings(price, containerSize, context):
    INPUT: Price details and context
    OUTPUT: Array of price warnings

    BEGIN
        warnings = []
        pricePerMl = price / containerSize

        // Check against historical averages
        IF context.cider THEN
            avgPrice = context.cider.averagePricePerMl
            IF avgPrice AND pricePerMl > (avgPrice * 1.5) THEN
                warnings.append({
                    type: "unusually_expensive",
                    message: `This price is significantly higher than your average (£${avgPrice.toFixed(4)}/ml)`,
                    severity: "warning"
                })
            ELSE IF avgPrice AND pricePerMl < (avgPrice * 0.5) THEN
                warnings.append({
                    type: "unusually_cheap",
                    message: `This price is significantly lower than your average (£${avgPrice.toFixed(4)}/ml)`,
                    severity: "info"
                })
            END IF
        END IF

        // Check for unrealistic prices
        IF pricePerMl > 0.02 THEN  // > 2p per ml is very expensive
            warnings.append({
                type: "very_expensive",
                message: "This is an unusually high price per ml for cider",
                severity: "warning"
            })
        ELSE IF pricePerMl < 0.001 THEN  // < 0.1p per ml is suspiciously cheap
            warnings.append({
                type: "very_cheap",
                message: "This price seems unusually low - please double check",
                severity: "warning"
            })
        END IF

        // Check container size reasonableness
        IF containerSize > 1000 THEN  // Over 1 litre
            warnings.append({
                type: "large_container",
                message: "Large container size - please verify this is correct",
                severity: "info"
            })
        ELSE IF containerSize < 200 THEN  // Under 200ml
            warnings.append({
                type: "small_container",
                message: "Small container size - please verify this is correct",
                severity: "info"
            })
        END IF

        RETURN warnings
    END
```

### Location Services Integration
```
ALGORITHM: LocationService
PURPOSE: GPS location capture and address resolution

INTERFACE LocationService:
    PROPERTIES:
        isLocationEnabled: boolean
        currentLocation: GPSCoordinates
        geocoder: GeocodingService
        accuracy: LocationAccuracy

FUNCTION startLocationDetection():
    INPUT: None
    OUTPUT: Started location detection process

    BEGIN
        TRY
            // Check location permissions
            permissions = await checkLocationPermissions()

            IF NOT permissions.granted THEN
                this.isLocationEnabled = false
                RETURN { success: false, reason: "permissions_denied" }
            END IF

            // Start location tracking
            watchId = navigator.geolocation.watchPosition(
                this.handleLocationUpdate,
                this.handleLocationError,
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 300000  // 5 minutes
                }
            )

            this.isLocationEnabled = true
            RETURN { success: true, watchId: watchId }

        CATCH error AS locationError
            this.handleLocationError(locationError)
            RETURN { success: false, reason: "location_error" }
        END TRY
    END

FUNCTION handleLocationUpdate(position):
    INPUT: GPS position object
    OUTPUT: Updated location state

    BEGIN
        this.currentLocation = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: position.timestamp
        }

        // Reverse geocode to get address
        this.reverseGeocodeLocation(this.currentLocation)

        // Trigger venue detection
        venueDetector.detectVenueFromLocation(this.currentLocation)
    END

FUNCTION reverseGeocodeLocation(location):
    INPUT: GPS coordinates
    OUTPUT: Promise<AddressInfo>

    BEGIN
        TRY
            addressInfo = await this.geocoder.reverseGeocode(location)

            processedAddress = {
                formatted: addressInfo.formatted_address,
                streetNumber: addressInfo.street_number,
                route: addressInfo.route,
                locality: addressInfo.locality,
                postalCode: addressInfo.postal_code,
                country: addressInfo.country,
                poi: addressInfo.poi,  // Points of interest
                establishment: addressInfo.establishment
            }

            RETURN processedAddress

        CATCH error AS geocodeError
            console.warn("Reverse geocoding failed:", geocodeError)
            RETURN null
        END TRY
    END

FUNCTION calculateDistance(location1, location2):
    INPUT: Two GPS coordinate objects
    OUTPUT: Distance in meters

    BEGIN
        // Haversine formula for calculating distance
        R = 6371000  // Earth radius in meters

        lat1Rad = toRadians(location1.latitude)
        lat2Rad = toRadians(location2.latitude)
        deltaLatRad = toRadians(location2.latitude - location1.latitude)
        deltaLngRad = toRadians(location2.longitude - location1.longitude)

        a = Math.sin(deltaLatRad/2) * Math.sin(deltaLatRad/2) +
            Math.cos(lat1Rad) * Math.cos(lat2Rad) *
            Math.sin(deltaLngRad/2) * Math.sin(deltaLngRad/2)

        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

        distance = R * c

        RETURN distance
    END
```

### Experience Validation Engine
```
ALGORITHM: ExperienceValidationEngine
PURPOSE: Validate experience entry with contextual checks

FUNCTION validateExperienceForm(formState):
    INPUT: Complete experience form state
    OUTPUT: ValidationResult with errors and warnings

    BEGIN
        result = {
            isValid: true,
            errors: [],
            warnings: [],
            suggestions: []
        }

        // Validate required fields
        result = validateRequiredFields(formState, result)

        // Validate price and container size
        result = validatePriceData(formState, result)

        // Validate date
        result = validateExperienceDate(formState, result)

        // Validate venue
        result = validateVenueData(formState, result)

        // Check for potential duplicates
        result = await checkDuplicateExperience(formState, result)

        // Generate contextual warnings
        result = generateContextualWarnings(formState, result)

        result.isValid = result.errors.length == 0

        RETURN result
    END

FUNCTION validatePriceData(formState, result):
    INPUT: Form state and current validation result
    OUTPUT: Updated validation result

    BEGIN
        // Price validation
        IF formState.price IS NULL OR formState.price <= 0 THEN
            result.errors.append("Price is required and must be positive")
        ELSE IF formState.price > 100 THEN
            result.warnings.append("Price seems unusually high for a single drink")
        END IF

        // Container size validation
        IF formState.containerSize IS NULL OR formState.containerSize <= 0 THEN
            result.errors.append("Container size is required and must be positive")
        END IF

        // Price per ml warnings
        IF formState.price AND formState.containerSize THEN
            priceWarnings = generatePriceWarnings(
                formState.price,
                formState.containerSize,
                { cider: formState.cider, venue: formState.venue }
            )
            result.warnings = result.warnings.concat(priceWarnings)
        END IF

        RETURN result
    END

FUNCTION validateExperienceDate(formState, result):
    INPUT: Form state and validation result
    OUTPUT: Updated validation result

    BEGIN
        IF formState.date IS NULL THEN
            result.errors.append("Experience date is required")
            RETURN result
        END IF

        currentDate = getCurrentDate()

        IF formState.date > currentDate THEN
            result.errors.append("Experience date cannot be in the future")
        END IF

        // Warn about very old dates
        daysDiff = (currentDate - formState.date) / (1000 * 60 * 60 * 24)
        IF daysDiff > 365 THEN
            result.warnings.append("This experience is more than a year old")
        ELSE IF daysDiff > 30 THEN
            result.warnings.append("This experience is more than a month old")
        END IF

        RETURN result
    END

FUNCTION checkDuplicateExperience(formState, result):
    INPUT: Form state and validation result
    OUTPUT: Promise<ValidationResult> with duplicate checks

    BEGIN
        // Look for potential duplicate experiences
        potentialDuplicates = await findSimilarExperiences({
            ciderId: formState.ciderId,
            venueId: formState.venue?.id,
            date: formState.date,
            toleranceHours: 24  // Within 24 hours
        })

        IF potentialDuplicates.length > 0 THEN
            duplicate = potentialDuplicates[0]

            result.warnings.append({
                type: "potential_duplicate",
                message: `You may have already logged this cider at ${duplicate.venue.name} on ${formatDate(duplicate.date)}`,
                data: duplicate
            })
        END IF

        RETURN result
    END
```

### Experience Submission Controller
```
ALGORITHM: ExperienceSubmissionController
PURPOSE: Handle experience submission with venue consolidation

FUNCTION submitExperience(formState):
    INPUT: Validated experience form state
    OUTPUT: Promise<SubmissionResult>

    PRECONDITIONS:
        - Form must pass validation
        - Cider must exist
        - User must be authenticated

    BEGIN
        // Step 1: Final validation
        finalValidation = await validateExperienceForm(formState)
        IF NOT finalValidation.isValid THEN
            THROW ValidationError(finalValidation.errors)
        END IF

        // Step 2: Show submission state
        updateFormState({ isSubmitting: true })
        analytics.startTimer("experience_submission")

        // Step 3: Process venue data
        processedVenue = await venueDetector.consolidateVenueName(
            formState.venue.name,
            formState.venue.location
        )

        // Step 4: Calculate derived fields
        pricePerMl = calculatePricePerMl(formState.price, formState.containerSize)
        valueRating = calculateValueRating(
            formState.experienceRating,
            pricePerMl,
            { venue: processedVenue }
        )

        // Step 5: Create experience record
        experienceData = {
            ciderId: formState.ciderId,
            date: formState.date,
            venue: processedVenue,
            price: formState.price,
            containerSize: formState.containerSize,
            pricePerMl: pricePerMl,
            experienceRating: formState.experienceRating,
            notes: formState.notes.trim() || null,
            companionCount: formState.companionCount,
            weatherCondition: formState.weatherCondition,
            valueRating: valueRating,
            location: formState.venue.location
        }

        TRY
            // Step 6: Create experience via store
            newExperience = await experienceStore.addExperience(experienceData)

            // Step 7: Update related analytics
            await updateCiderStatistics(formState.ciderId)
            await updateVenueAnalytics(processedVenue.id)

            // Step 8: Record success
            analytics.recordSuccess("experience_submission")
            showSuccessNotification("Experience logged successfully!")

            result = {
                success: true,
                experienceId: newExperience.id,
                experience: newExperience,
                venue: processedVenue
            }

            RETURN result

        CATCH error AS submitError
            // Step 9: Handle submission errors
            updateFormState({ isSubmitting: false })
            analytics.recordError("experience_submission", submitError)

            errorMessage = getUserFriendlyErrorMessage(submitError)
            showErrorNotification(errorMessage)

            THROW SubmissionError(errorMessage, submitError)
        END TRY
    END
```

### Venue Analytics Integration
```
ALGORITHM: VenueAnalyticsUpdater
PURPOSE: Update venue analytics after experience logging

FUNCTION updateVenueAnalytics(venueId):
    INPUT: Venue ID that needs analytics update
    OUTPUT: Promise<void>

    BEGIN
        // Get all experiences for this venue
        venueExperiences = await getExperiencesForVenue(venueId)

        // Calculate updated analytics
        analytics = {
            visitCount: venueExperiences.length,
            uniqueCidersCount: countUniqueCiders(venueExperiences),
            totalSpent: calculateTotalSpent(venueExperiences),
            averagePricePerMl: calculateAveragePricePerMl(venueExperiences),
            priceRange: calculatePriceRange(venueExperiences),
            lastVisit: getLatestVisitDate(venueExperiences),
            firstVisit: getEarliestVisitDate(venueExperiences),
            averageRating: calculateAverageRating(venueExperiences),
            favoriteContainerSize: getMostCommonContainerSize(venueExperiences)
        }

        // Update venue record
        await venueStore.updateVenueAnalytics(venueId, analytics)
    END

FUNCTION calculateTotalSpent(experiences):
    INPUT: Array of experiences
    OUTPUT: Total amount spent at venue

    BEGIN
        RETURN experiences.reduce((total, exp) => total + exp.price, 0)
    END

FUNCTION calculateAveragePricePerMl(experiences):
    INPUT: Array of experiences
    OUTPUT: Average price per ml

    BEGIN
        IF experiences.length == 0 THEN
            RETURN 0
        END IF

        totalPricePerMl = experiences.reduce((sum, exp) => sum + exp.pricePerMl, 0)
        RETURN totalPricePerMl / experiences.length
    END

FUNCTION calculatePriceRange(experiences):
    INPUT: Array of experiences
    OUTPUT: Price range object

    BEGIN
        IF experiences.length == 0 THEN
            RETURN { min: 0, max: 0, median: 0 }
        END IF

        pricesPerMl = experiences.map(exp => exp.pricePerMl).sort((a, b) => a - b)

        RETURN {
            min: pricesPerMl[0],
            max: pricesPerMl[pricesPerMl.length - 1],
            median: calculateMedian(pricesPerMl)
        }
    END
```

This comprehensive experience logging system provides:

1. **Venue Intelligence**: Smart venue detection and consolidation
2. **Price Analytics**: Automatic price per ml calculation with contextual warnings
3. **Location Integration**: GPS capture and reverse geocoding
4. **Value Calculations**: Context-aware value ratings and comparisons
5. **Duplicate Prevention**: Detection of potential duplicate experiences
6. **Validation Engine**: Comprehensive validation with helpful warnings
7. **Analytics Integration**: Automatic venue and cider statistics updates
8. **Offline Support**: Full functionality without internet connection

The workflow optimizes for quick experience entry while providing intelligent feedback and maintaining data quality through smart validation and consolidation.