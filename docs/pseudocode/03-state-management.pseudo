# State Management Pseudocode
# Cider Dictionary - Foundation Architecture Phase 1

## Overview
This pseudocode defines the state management architecture using Zustand for global state
and React Query for server state management, optimized for offline-first functionality.

## State Management Architecture

### Global State Strategy
```
ARCHITECTURE: State Management Design
PURPOSE: Lightweight, efficient state management with offline-first principles

LAYERS:
    1. Zustand Stores: Global application state (UI state, user preferences)
    2. React Query: Server state with caching (Firebase data)
    3. Local Database: Offline persistence layer
    4. MMKV: Fast key-value storage for preferences

PRINCIPLES:
    - Single source of truth per data type
    - Optimistic updates for better UX
    - Automatic background sync
    - Minimal re-renders through selective subscriptions
```

## Zustand Store Definitions

### User Store
```
ALGORITHM: UserStore Definition
PURPOSE: Manage user authentication state and preferences

INTERFACE UserStore:
    STATE:
        user: User | null
        isAuthenticated: boolean
        preferences: UserPreferences
        isLoading: boolean
        error: string | null

    ACTIONS:
        setUser: (user: User) => void
        updatePreferences: (preferences: Partial<UserPreferences>) => void
        logout: () => Promise<void>
        clearError: () => void

IMPLEMENTATION UserStore:
    CREATE_STORE:
        initialState = {
            user: null,
            isAuthenticated: false,
            preferences: getDefaultPreferences(),
            isLoading: false,
            error: null
        }

    FUNCTION setUser(user):
        INPUT: User object from authentication
        OUTPUT: Updated store state

        BEGIN
            setState({
                user: user,
                isAuthenticated: user !== null,
                error: null
            })

            IF user IS NOT NULL THEN
                // Load user preferences from local storage
                savedPreferences = await loadPreferencesFromMMKV(user.id)
                IF savedPreferences THEN
                    setState({ preferences: savedPreferences })
                END IF
            END IF
        END

    FUNCTION updatePreferences(newPreferences):
        INPUT: Partial preferences object
        OUTPUT: Updated store state

        BEGIN
            currentPreferences = getState().preferences
            updatedPreferences = { ...currentPreferences, ...newPreferences }

            setState({ preferences: updatedPreferences })

            // Persist to local storage immediately
            IF getState().user THEN
                await savePreferencesToMMKV(getState().user.id, updatedPreferences)
            END IF

            // Sync to Firebase in background
            await syncPreferencesToFirebase(updatedPreferences)
        END

    FUNCTION logout():
        INPUT: None
        OUTPUT: Cleared store state

        BEGIN
            setState({
                user: null,
                isAuthenticated: false,
                preferences: getDefaultPreferences(),
                error: null
            })

            // Clear local data
            await clearUserDataFromMMKV()
            await clearLocalDatabase()
        END

FUNCTION getDefaultPreferences():
    INPUT: None
    OUTPUT: Default UserPreferences object

    BEGIN
        RETURN {
            defaultContainerSize: 568,  // Pint glass
            ratingScale: "1-10",
            autoLocationCapture: true,
            units: "metric",
            quickEntryDefaults: {
                rememberLastVenue: true,
                autoFillLocation: true,
                showDetailedFields: false,
                enableDuplicateWarnings: true
            }
        }
    END
```

### Cider Store
```
ALGORITHM: CiderStore Definition
PURPOSE: Manage cider collection state with optimistic updates

INTERFACE CiderStore:
    STATE:
        ciders: CiderMasterRecord[]
        selectedCider: CiderMasterRecord | null
        isLoading: boolean
        searchQuery: string
        searchResults: CiderMasterRecord[]
        filters: CiderFilters
        sortBy: SortCriteria
        isDraft: boolean
        draftCider: Partial<CiderMasterRecord>

    ACTIONS:
        setCiders: (ciders: CiderMasterRecord[]) => void
        addCider: (cider: CiderMasterRecord) => Promise<void>
        updateCider: (ciderId: string, updates: Partial<CiderMasterRecord>) => Promise<void>
        deleteCider: (ciderId: string) => Promise<void>
        selectCider: (ciderId: string) => void
        searchCiders: (query: string) => void
        setFilters: (filters: Partial<CiderFilters>) => void
        setSortBy: (sortBy: SortCriteria) => void
        saveDraft: (draftData: Partial<CiderMasterRecord>) => void
        clearDraft: () => void

IMPLEMENTATION CiderStore:
    DEPENDENCIES:
        databaseService: DatabaseServiceManager
        syncManager: SyncManager

    FUNCTION addCider(ciderData):
        INPUT: New cider data
        OUTPUT: Promise<void> with optimistic update

        BEGIN
            // Generate optimistic ID
            optimisticId = generateOptimisticId()
            optimisticCider = {
                ...ciderData,
                id: optimisticId,
                createdAt: getCurrentTimestamp(),
                syncStatus: "pending"
            }

            // Optimistic update - add to state immediately
            currentCiders = getState().ciders
            setState({
                ciders: [...currentCiders, optimisticCider],
                isDraft: false,
                draftCider: {}
            })

            TRY
                // Create in database
                actualCider = await this.databaseService.createCider(ciderData)

                // Replace optimistic cider with actual cider
                updatedCiders = currentCiders.map(c =>
                    c.id === optimisticId ? actualCider : c
                )
                setState({ ciders: updatedCiders })

            CATCH error AS createError
                // Rollback optimistic update
                rollbackCiders = currentCiders.filter(c => c.id !== optimisticId)
                setState({
                    ciders: rollbackCiders,
                    error: createError.message
                })
                THROW createError
            END TRY
        END

    FUNCTION updateCider(ciderId, updates):
        INPUT: Cider ID and update data
        OUTPUT: Promise<void> with optimistic update

        BEGIN
            // Find current cider
            currentCiders = getState().ciders
            ciderIndex = currentCiders.findIndex(c => c.id === ciderId)

            IF ciderIndex === -1 THEN
                THROW NotFoundError("Cider not found")
            END IF

            originalCider = currentCiders[ciderIndex]
            optimisticCider = {
                ...originalCider,
                ...updates,
                updatedAt: getCurrentTimestamp(),
                syncStatus: "pending"
            }

            // Optimistic update
            optimisticCiders = [...currentCiders]
            optimisticCiders[ciderIndex] = optimisticCider
            setState({ ciders: optimisticCiders })

            TRY
                actualCider = await this.databaseService.updateCider(ciderId, updates)

                // Replace with actual result
                finalCiders = [...currentCiders]
                finalCiders[ciderIndex] = actualCider
                setState({ ciders: finalCiders })

            CATCH error AS updateError
                // Rollback to original state
                rollbackCiders = [...currentCiders]
                rollbackCiders[ciderIndex] = originalCider
                setState({
                    ciders: rollbackCiders,
                    error: updateError.message
                })
                THROW updateError
            END TRY
        END

    FUNCTION searchCiders(query):
        INPUT: Search query string
        OUTPUT: Updated search results in state

        BEGIN
            setState({
                searchQuery: query,
                isLoading: true
            })

            IF query.length < 2 THEN
                setState({
                    searchResults: [],
                    isLoading: false
                })
                RETURN
            END IF

            // Debounced search to avoid excessive calls
            clearTimeout(this.searchTimeout)
            this.searchTimeout = setTimeout(async () => {
                TRY
                    results = await this.databaseService.searchCiders(query, {
                        filters: getState().filters,
                        limit: 20
                    })

                    setState({
                        searchResults: results,
                        isLoading: false
                    })

                CATCH error AS searchError
                    setState({
                        searchResults: [],
                        isLoading: false,
                        error: searchError.message
                    })
                END TRY
            }, 300)  // 300ms debounce
        END

    FUNCTION saveDraft(draftData):
        INPUT: Partial cider data
        OUTPUT: Updated draft state

        BEGIN
            setState({
                isDraft: true,
                draftCider: draftData
            })

            // Auto-save draft to local storage
            await saveToMMKV("cider_draft", {
                data: draftData,
                timestamp: getCurrentTimestamp()
            })
        END

    FUNCTION loadDraft():
        INPUT: None
        OUTPUT: Restored draft state

        BEGIN
            savedDraft = await loadFromMMKV("cider_draft")

            IF savedDraft AND savedDraft.timestamp > (getCurrentTimestamp() - 24 * 60 * 60 * 1000) THEN
                // Draft is less than 24 hours old
                setState({
                    isDraft: true,
                    draftCider: savedDraft.data
                })
                RETURN true
            END IF

            RETURN false
        END
```

### Experience Store
```
ALGORITHM: ExperienceStore Definition
PURPOSE: Manage experience logging with venue analytics

INTERFACE ExperienceStore:
    STATE:
        experiences: ExperienceLog[]
        selectedExperience: ExperienceLog | null
        venues: VenueRecord[]
        recentVenues: VenueRecord[]
        isLogging: boolean
        logFormData: Partial<ExperienceLog>

    ACTIONS:
        setExperiences: (experiences: ExperienceLog[]) => void
        addExperience: (experience: Partial<ExperienceLog>) => Promise<void>
        updateExperience: (experienceId: string, updates: Partial<ExperienceLog>) => Promise<void>
        deleteExperience: (experienceId: string) => Promise<void>
        getExperiencesForCider: (ciderId: string) => ExperienceLog[]
        setLogFormData: (data: Partial<ExperienceLog>) => void
        clearLogForm: () => void
        getRecentVenues: () => VenueRecord[]

IMPLEMENTATION ExperienceStore:
    FUNCTION addExperience(experienceData):
        INPUT: New experience data
        OUTPUT: Promise<void> with optimistic update

        BEGIN
            optimisticId = generateOptimisticId()
            optimisticExperience = {
                ...experienceData,
                id: optimisticId,
                createdAt: getCurrentTimestamp(),
                syncStatus: "pending"
            }

            // Optimistic update
            currentExperiences = getState().experiences
            setState({
                experiences: [optimisticExperience, ...currentExperiences],
                isLogging: false,
                logFormData: {}
            })

            TRY
                actualExperience = await this.databaseService.createExperience(experienceData)

                // Replace optimistic with actual
                updatedExperiences = getState().experiences.map(e =>
                    e.id === optimisticId ? actualExperience : e
                )
                setState({ experiences: updatedExperiences })

                // Update related stores
                await this.updateRelatedData(actualExperience)

            CATCH error AS createError
                // Rollback optimistic update
                rollbackExperiences = currentExperiences
                setState({
                    experiences: rollbackExperiences,
                    error: createError.message
                })
                THROW createError
            END TRY
        END

    FUNCTION updateRelatedData(experience):
        INPUT: New or updated experience
        OUTPUT: Updated related stores

        BEGIN
            // Update cider statistics in cider store
            ciderStore = useCiderStore.getState()
            await ciderStore.refreshCiderStats(experience.ciderId)

            // Update venue analytics
            venueStore = useVenueStore.getState()
            await venueStore.updateVenueAnalytics(experience.venue.id)
        END

    FUNCTION getExperiencesForCider(ciderId):
        INPUT: Cider ID
        OUTPUT: Filtered experiences array

        BEGIN
            allExperiences = getState().experiences
            RETURN allExperiences.filter(exp => exp.ciderId === ciderId)
                                  .sort((a, b) => b.date - a.date)
        END

    FUNCTION getRecentVenues():
        INPUT: None
        OUTPUT: Recent venues sorted by last visit

        BEGIN
            experiences = getState().experiences
            venueVisits = {}

            // Aggregate venue visits
            FOR EACH experience IN experiences DO
                venueId = experience.venue.id
                IF NOT venueVisits[venueId] THEN
                    venueVisits[venueId] = {
                        venue: experience.venue,
                        lastVisit: experience.date,
                        visitCount: 0
                    }
                END IF

                venueVisits[venueId].visitCount++
                IF experience.date > venueVisits[venueId].lastVisit THEN
                    venueVisits[venueId].lastVisit = experience.date
                END IF
            END FOR

            // Sort by last visit and return top 10
            recentVenues = Object.values(venueVisits)
                                .sort((a, b) => b.lastVisit - a.lastVisit)
                                .slice(0, 10)

            setState({ recentVenues: recentVenues })
            RETURN recentVenues
        END
```

## React Query Integration

### Query Configuration
```
ALGORITHM: React Query Setup
PURPOSE: Server state management with caching and synchronization

CONFIGURATION ReactQueryConfig:
    defaultOptions = {
        queries: {
            staleTime: 5 * 60 * 1000,     // 5 minutes
            cacheTime: 10 * 60 * 1000,    // 10 minutes
            retry: 3,
            retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
            refetchOnWindowFocus: false,
            refetchOnReconnect: true
        },
        mutations: {
            retry: 2,
            retryDelay: 1000
        }
    }

FUNCTION setupQueryClient():
    INPUT: None
    OUTPUT: Configured QueryClient

    BEGIN
        queryClient = new QueryClient({
            defaultOptions: ReactQueryConfig.defaultOptions
        })

        // Setup global error handling
        queryClient.setMutationDefaults(["cider"], {
            onError: (error) => {
                // Log error for debugging
                console.error("Mutation error:", error)

                // Show user-friendly error message
                showErrorToast(error.message)
            }
        })

        RETURN queryClient
    END
```

### Cider Queries
```
ALGORITHM: Cider Query Hooks
PURPOSE: React Query hooks for cider data management

FUNCTION useCidersQuery(filters, sortBy):
    INPUT: Optional filters and sort criteria
    OUTPUT: Query result with ciders data

    BEGIN
        RETURN useQuery({
            queryKey: ["ciders", filters, sortBy],
            queryFn: async () => {
                return await databaseService.getCiderCollection(filters, sortBy, 100)
            },
            staleTime: 2 * 60 * 1000,  // 2 minutes for collection data
            onSuccess: (data) => {
                // Update Zustand store
                ciderStore.setCiders(data)
            }
        })
    END

FUNCTION useCiderQuery(ciderId):
    INPUT: Cider ID
    OUTPUT: Query result with single cider

    BEGIN
        RETURN useQuery({
            queryKey: ["cider", ciderId],
            queryFn: async () => {
                return await databaseService.getCiderById(ciderId)
            },
            enabled: Boolean(ciderId),
            onSuccess: (data) => {
                if (data) {
                    ciderStore.selectCider(data.id)
                }
            }
        })
    END

FUNCTION useCreateCiderMutation():
    INPUT: None
    OUTPUT: Mutation function for creating ciders

    BEGIN
        queryClient = useQueryClient()

        RETURN useMutation({
            mutationFn: async (ciderData) => {
                return await databaseService.createCider(ciderData)
            },
            onMutate: async (newCider) => {
                // Cancel outgoing refetches
                await queryClient.cancelQueries(["ciders"])

                // Snapshot previous value
                previousCiders = queryClient.getQueryData(["ciders"])

                // Optimistically update
                queryClient.setQueryData(["ciders"], (old) => {
                    return old ? [...old, { ...newCider, id: "temp-" + Date.now() }] : [newCider]
                })

                RETURN { previousCiders }
            },
            onError: (error, newCider, context) => {
                // Rollback optimistic update
                queryClient.setQueryData(["ciders"], context.previousCiders)
            },
            onSettled: () => {
                // Refetch to ensure consistency
                queryClient.invalidateQueries(["ciders"])
            }
        })
    END

FUNCTION useUpdateCiderMutation():
    INPUT: None
    OUTPUT: Mutation function for updating ciders

    BEGIN
        queryClient = useQueryClient()

        RETURN useMutation({
            mutationFn: async ({ ciderId, updates }) => {
                return await databaseService.updateCider(ciderId, updates)
            },
            onMutate: async ({ ciderId, updates }) => {
                await queryClient.cancelQueries(["cider", ciderId])
                await queryClient.cancelQueries(["ciders"])

                // Snapshot previous values
                previousCider = queryClient.getQueryData(["cider", ciderId])
                previousCiders = queryClient.getQueryData(["ciders"])

                // Optimistic updates
                queryClient.setQueryData(["cider", ciderId], (old) => {
                    return old ? { ...old, ...updates } : null
                })

                queryClient.setQueryData(["ciders"], (old) => {
                    return old ? old.map(c => c.id === ciderId ? { ...c, ...updates } : c) : []
                })

                RETURN { previousCider, previousCiders }
            },
            onError: (error, variables, context) => {
                // Rollback optimistic updates
                queryClient.setQueryData(["cider", variables.ciderId], context.previousCider)
                queryClient.setQueryData(["ciders"], context.previousCiders)
            },
            onSettled: (data, error, variables) => {
                queryClient.invalidateQueries(["cider", variables.ciderId])
                queryClient.invalidateQueries(["ciders"])
            }
        })
    END
```

### Experience Queries
```
ALGORITHM: Experience Query Hooks
PURPOSE: React Query hooks for experience data management

FUNCTION useExperiencesQuery(ciderId):
    INPUT: Optional cider ID to filter experiences
    OUTPUT: Query result with experiences data

    BEGIN
        RETURN useQuery({
            queryKey: ["experiences", ciderId],
            queryFn: async () => {
                IF ciderId THEN
                    return await databaseService.getExperiencesForCider(ciderId)
                ELSE
                    return await databaseService.getAllExperiences()
                END IF
            },
            onSuccess: (data) => {
                experienceStore.setExperiences(data)
            }
        })
    END

FUNCTION useCreateExperienceMutation():
    INPUT: None
    OUTPUT: Mutation function for creating experiences

    BEGIN
        queryClient = useQueryClient()

        RETURN useMutation({
            mutationFn: async (experienceData) => {
                return await databaseService.createExperience(experienceData)
            },
            onSuccess: (data) => {
                // Invalidate related queries
                queryClient.invalidateQueries(["experiences"])
                queryClient.invalidateQueries(["cider", data.ciderId])
                queryClient.invalidateQueries(["venues"])
                queryClient.invalidateQueries(["analytics"])
            }
        })
    END
```

## State Synchronization Patterns

### Offline-First State Sync
```
ALGORITHM: OfflineFirstSyncManager
PURPOSE: Coordinate state between local stores and remote data

CLASS OfflineFirstSyncManager:
    PROPERTIES:
        syncInterval: number = 30000  // 30 seconds
        isOnline: boolean = true
        lastSyncTime: number = 0

    FUNCTION initialize():
        INPUT: None
        OUTPUT: Started sync manager

        BEGIN
            // Monitor network state
            this.networkMonitor.onStateChange((isOnline) => {
                this.isOnline = isOnline
                IF isOnline THEN
                    this.performSync()
                END IF
            })

            // Setup periodic sync when online
            setInterval(() => {
                IF this.isOnline THEN
                    this.performSync()
                END IF
            }, this.syncInterval)

            // Initial sync
            IF this.isOnline THEN
                this.performSync()
            END IF
        END

    FUNCTION performSync():
        INPUT: None
        OUTPUT: Promise<SyncResult>

        BEGIN
            TRY
                // Sync pending operations from queue
                queueResult = await syncManager.processPendingOperations()

                // Download updates from Firebase
                downloadResult = await this.downloadUpdates()

                // Update last sync time
                this.lastSyncTime = getCurrentTimestamp()
                await saveToMMKV("last_sync_time", this.lastSyncTime)

                // Notify stores of successful sync
                this.notifyStoresOfSync()

                RETURN {
                    success: true,
                    uploaded: queueResult.success,
                    downloaded: downloadResult.count,
                    errors: queueResult.errors
                }

            CATCH error AS syncError
                console.error("Sync failed:", syncError)
                RETURN {
                    success: false,
                    error: syncError.message
                }
            END TRY
        END

    FUNCTION downloadUpdates():
        INPUT: None
        OUTPUT: Promise<DownloadResult>

        BEGIN
            lastSync = this.lastSyncTime
            downloadCount = 0

            // Download updated ciders
            updatedCiders = await firestore
                .collection("ciders")
                .where("userId", "==", getCurrentUserId())
                .where("updatedAt", ">", lastSync)
                .get()

            FOR EACH doc IN updatedCiders.docs DO
                ciderData = doc.data()
                await this.mergeCiderData(ciderData)
                downloadCount++
            END FOR

            // Download updated experiences
            updatedExperiences = await firestore
                .collection("experiences")
                .where("userId", "==", getCurrentUserId())
                .where("updatedAt", ">", lastSync)
                .get()

            FOR EACH doc IN updatedExperiences.docs DO
                experienceData = doc.data()
                await this.mergeExperienceData(experienceData)
                downloadCount++
            END FOR

            RETURN { count: downloadCount }
        END

    FUNCTION mergeCiderData(remoteData):
        INPUT: Remote cider data from Firebase
        OUTPUT: Updated local store and database

        BEGIN
            localData = await databaseService.getCiderById(remoteData.id)

            IF localData AND localData.syncStatus === "pending" THEN
                // Local changes pending, need conflict resolution
                mergedData = conflictResolver.resolveUpdateConflict(localData, remoteData)
                await databaseService.updateLocalCider(remgedData.id, mergedData)
            ELSE
                // Safe to update with remote data
                await databaseService.updateLocalCider(remoteData.id, remoteData)
            END IF

            // Update Zustand store
            ciderStore.getState().updateCiderInState(remoteData.id, remoteData)
        END

    FUNCTION notifyStoresOfSync():
        INPUT: None
        OUTPUT: Updated store states

        BEGIN
            // Refresh query cache
            queryClient.invalidateQueries(["ciders"])
            queryClient.invalidateQueries(["experiences"])
            queryClient.invalidateQueries(["venues"])

            // Update sync status in stores
            syncStore.getState().setSyncStatus({
                lastSync: this.lastSyncTime,
                isOnline: this.isOnline,
                pendingOperations: 0
            })
        END
```

### State Persistence
```
ALGORITHM: StatePersistenceManager
PURPOSE: Persist critical state across app restarts

FUNCTION persistStoreState():
    INPUT: None
    OUTPUT: Saved state to MMKV

    BEGIN
        // Save user preferences
        userState = userStore.getState()
        await saveToMMKV("user_preferences", userState.preferences)

        // Save search and filter state
        ciderState = ciderStore.getState()
        searchState = {
            searchQuery: ciderState.searchQuery,
            filters: ciderState.filters,
            sortBy: ciderState.sortBy
        }
        await saveToMMKV("search_state", searchState)

        // Save draft data
        IF ciderState.isDraft THEN
            await saveToMMKV("cider_draft", {
                data: ciderState.draftCider,
                timestamp: getCurrentTimestamp()
            })
        END IF
    END

FUNCTION restoreStoreState():
    INPUT: None
    OUTPUT: Restored store states

    BEGIN
        // Restore user preferences
        savedPreferences = await loadFromMMKV("user_preferences")
        IF savedPreferences THEN
            userStore.getState().updatePreferences(savedPreferences)
        END IF

        // Restore search state
        savedSearchState = await loadFromMMKV("search_state")
        IF savedSearchState THEN
            ciderStore.getState().setFilters(savedSearchState.filters)
            ciderStore.getState().setSortBy(savedSearchState.sortBy)
        END IF

        // Restore draft if recent
        savedDraft = await loadFromMMKV("cider_draft")
        IF savedDraft AND isRecentDraft(savedDraft.timestamp) THEN
            ciderStore.getState().saveDraft(savedDraft.data)
        END IF
    END

FUNCTION isRecentDraft(draftTimestamp):
    INPUT: Draft timestamp
    OUTPUT: Boolean indicating if draft is recent enough to restore

    BEGIN
        maxAge = 24 * 60 * 60 * 1000  // 24 hours
        age = getCurrentTimestamp() - draftTimestamp
        RETURN age < maxAge
    END
```

## Performance Optimizations

### Selective Store Subscriptions
```
ALGORITHM: SelectiveSubscriptions
PURPOSE: Minimize re-renders through targeted state subscriptions

FUNCTION useSelectiveCiderState(selector):
    INPUT: State selector function
    OUTPUT: Selected state slice with shallow comparison

    BEGIN
        RETURN useCiderStore(
            useCallback(selector, []),
            shallow  // Zustand shallow comparison
        )
    END

EXAMPLE USAGE:
    // Only re-render when search results change
    searchResults = useSelectiveCiderState(state => state.searchResults)

    // Only re-render when loading state changes
    isLoading = useSelectiveCiderState(state => state.isLoading)

    // Only re-render when specific cider changes
    selectedCider = useSelectiveCiderState(state =>
        state.ciders.find(c => c.id === selectedId)
    )
```

### Store Action Batching
```
ALGORITHM: ActionBatching
PURPOSE: Batch multiple state updates to reduce renders

FUNCTION batchCiderUpdates(updates):
    INPUT: Array of cider updates
    OUTPUT: Single state update

    BEGIN
        ciderStore.getState().setState((state) => {
            newCiders = [...state.ciders]

            FOR EACH update IN updates DO
                index = newCiders.findIndex(c => c.id === update.id)
                IF index >= 0 THEN
                    newCiders[index] = { ...newCiders[index], ...update.data }
                END IF
            END FOR

            RETURN { ciders: newCiders }
        })
    END
```

## Error Handling and Recovery

### Store Error Management
```
ALGORITHM: StoreErrorHandler
PURPOSE: Centralized error handling across all stores

CLASS StoreErrorHandler:
    FUNCTION handleStoreError(storeName, action, error):
        INPUT: Store name, action name, and error object
        OUTPUT: Updated error state and user notification

        BEGIN
            errorInfo = {
                store: storeName,
                action: action,
                message: error.message,
                timestamp: getCurrentTimestamp(),
                stack: error.stack
            }

            // Log error for debugging
            console.error("Store error:", errorInfo)

            // Update error state in relevant store
            SWITCH storeName:
                CASE "cider":
                    ciderStore.getState().setState({ error: error.message })
                CASE "experience":
                    experienceStore.getState().setState({ error: error.message })
                CASE "user":
                    userStore.getState().setState({ error: error.message })
            END SWITCH

            // Show user-friendly error message
            this.showErrorToUser(error)

            // Attempt recovery if possible
            this.attemptRecovery(storeName, action, error)
        END

    FUNCTION attemptRecovery(storeName, action, error):
        INPUT: Error context information
        OUTPUT: Recovery action taken

        BEGIN
            SWITCH error.type:
                CASE "NETWORK_ERROR":
                    // Queue action for retry when online
                    syncManager.queueForRetry(storeName, action)

                CASE "VALIDATION_ERROR":
                    // Reset form state to last valid state
                    this.resetToLastValidState(storeName)

                CASE "CONFLICT_ERROR":
                    // Trigger conflict resolution UI
                    this.showConflictResolutionModal(error.details)

                DEFAULT:
                    // Generic recovery - clear error after timeout
                    setTimeout(() => {
                        this.clearError(storeName)
                    }, 5000)
            END SWITCH
        END
```

This comprehensive state management architecture provides:

1. **Optimistic Updates**: Immediate UI feedback with rollback on errors
2. **Offline-First**: All state operations work offline with automatic sync
3. **Performance Optimization**: Selective subscriptions and batched updates
4. **Error Recovery**: Comprehensive error handling with automatic recovery
5. **Data Consistency**: Proper state synchronization between local and remote
6. **Developer Experience**: Clean, predictable state management patterns

The state management layer bridges the database operations with the UI components, ensuring a smooth and responsive user experience while maintaining data integrity across online/offline scenarios.